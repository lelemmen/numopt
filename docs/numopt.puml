@startuml

namespace numopt {

    abstract class BaseNewtonDescent {
        __ protected members __
            # constexpr size_t maximum_number_of_iterations = 128
            # const double convergence_threshold = 1.0e-8

            # double converged = false

            # const Eigen::VectorXd x0
            # const Eigen::VectorXd x
        == constructors ==
            **BaseNewtonDescent**(const Eigen::VectorXd& x0, double convergence_threshold)
        __ public pure virtual methods __
            + virtual void **solve**() = 0
        __ public methods __
            + Eigen::VectorXd **get_solution**()
    }


    ScalarNewtonDescent --|> BaseNewtonDescent
    class ScalarNewtonDescent {
        __ private members __
            - const VectorFunction grad
            - const HessianFunction H
        == constructors ==
            **ScalarNewtonDescent**(const Eigen::VectorXd& x0, const VectorFunction& grad, const HessianFunction& H,
            double convergence_threshold = 1.0e-08)
    }


    VectorNewtonDescent --|> BaseNewtonDescent
    class VectorNewtonDescent {
        __ private members __
            - const VectorFunction f
            - const JacobianFunction J
        == constructors ==
            **VectorNewtonDescent**(const Eigen::VectorXd& x0, const VectorFunction& f, const JacobianFunction& J,
            double convergence_threshold = 1.0e-08)
        __ public methods __
            + Eigen::VectorXd **solve**()
    }



    namespace eigenproblem {


        abstract class BaseEigenproblemSolver {
            __ protected members __
                # const size_t dim

                # bool is_solved = false
                # double eigenvalue
                # Eigen::VectorXd eigenvector
            == protected constructors ==
                # explicit **BaseEigenproblemSolver**(size_t dim)
            == destructor ==
                virtual ~ **BaseEigenproblemSolver**() = default
            __ public pure virtual methods __
                + virtual void **solve**() = 0
            __ public methods __
                + **get_eigenvalue**() const
                + **get_eigenvector**() const
        }

        BaseMatrixSolver --|> BaseEigenproblemSolver
        abstract class BaseMatrixSolver {
            == constructor ==
                explicit BaseMatrixSolver(size_t dim)
            == destructor ==
                **~BaseMatrixSolver**() override = default
            __ public pure virtual methods __
                + virtual void **addToMatrix**(double value, size_t index1, size_t index2) = 0
        }


        DenseSolver --|> BaseMatrixSolver
        class DenseSolver {
            __ private members __
                - Eigen::MatrixXd matrix
            == constructors ==
                explicit **DenseSolver**(size_t dim)
            == destructor ==
                 **~DenseSolver**() override = default
            __ public methods __
                + void **solve**() override
                + void **addToMatrix**(double value, size_t index1, size_t index2) override
        }


        SparseSolver --|> BaseMatrixSolver
        class SparseSolver {
            __ private members __
                - Eigen::SparseMatrix<double> matrix
            == constructors ==
                explicit **SparseSolver**(size_t dim)
            == destructor ==
                 **~SparseSolver**() override = default
            __ public methods __
                + virtual void **solve**() override
                + void **addToMatrix**(double value, size_t index1, size_t index2) override
        }


        DavidsonSolver --|> BaseEigenproblemSolver
        class DavidsonSolver {
            __ private members __
                - constexpr size_t maximum_number_of_iterations = 128
                - const double convergence_threshold
                - const double correction_threshold
                - const size_t maximum_subspace_dimension
                - const size_t collapsed_subspace_dimension

                - const Eigen::VectorXd diagonal
                - const Eigen::VectorXd t_0
                - const numopt::VectorFunction matrixVectorProduct
            == constructors ==
                **DavidsonSolver**(const numopt::VectorFunction& matrixVectorProduct, const Eigen::VectorXd& diagonal, const Eigen::VectorXd& t_0,
                double convergence_threshold = 1.0e-08, double correction_threshold = 1.0e-12, size_t maximum_subspace_dimension = 15,
                size_t collapsed_subspace_dimension = 2)
                **DavidsonSolver**(const Eigen::MatrixXd& A, const Eigen::VectorXd& t_0,
                double convergence_threshold = 1.0e-08, double correction_threshold = 1.0e-12, size_t maximum_subspace_dimension = 15,
                size_t collapsed_subspace_dimension = 2)
            == destructor ==
                 **~DavidsonSolver**() override = default
            __ public methods __
                + void **solve**() override
        }


    }


}

@enduml