@startuml

namespace numopt {

    class NewtonDescent {
        __ private members __
            - const size_t MAX_NO_ITERATIONS = 128
            - const double THRESHOLD = 1.0e-8
        == constructors ==
            **Newton**(Eigen::VectorXd& x0, double (*f)(), Eigen::VectorXd (*gradf)())
        __ public methods __
            + double& **solve**()
    }


    class NewtonDescentVector {
        __ private members __
            - {static} constexpr size_t MAX_NUMBER_OF_ITERATIONS = 128
            - {static} const double convergence_threshold = 1.0e-8

            - double converged = false

            - const Eigen::VectorXd& x0
            - Eigen::VectorXd (*f)(Eigen::VectorXd& x)
            - Eigen::MatrixXd (*J)(Eigen::VectorXd& x)
        == constructors ==
            **NewtonDescentVector**(const Eigen::VectorXd& x0, const VectorFunction& f, const Jacobian& J, double convergence_threshold = 1.0e-08);
        __ public methods __
            + Eigen::VectorXd **solve**()
    }


    class DavidsonSolver {
        __ private members __
            - {static} constexpr size_t maximum_numer_of_iterations = 128
            - const double residue_tolerance
            - const double correction_threshold
            - const size_t maximum_subspace_dimension

            - const Eigen::VectorXd t0
            - const numopt::VectorFunction matrixVectorProduct

            - bool is_solved
            - double eigenvalue
            - Eigen::VectorXd eigenvector
        == constructors ==
            **DavidsonSolver**(const numopt::VectorFunction& matrixVectorProduct, const Eigen::VectorXd& t0, double residue_tolerance = 1.0e-08, double correction_threshold = 1.0e-03, size_t maximum_subspace_dimension = 15)
        __ public methods __
            + **get_eigenvalue**() const
            + **get_eigenvector**() const

            + **solve**()
    }
}

@enduml